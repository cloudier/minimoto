#!/usr/bin/python3

"""
All the AWS resources (EC2 instances, SQS queue, S3 buckets, AMIs, security
groups, etc.) needed to run a solution will be created and initialised using a
minimoto_setup program. The usage of the program is as follows (with sample
output):
    $ ./minimoto_setup keyfile aws_access_key_id aws_secret_access_key
    minimoto_setup: mandatory output messages follow
    S3_BUCKET_INPUT=s3://au.edu.unsw.cs9243.input
    S3_BUCKET_OUTPUT=s3://au.edu.unsw.cs9243.output
    CLIENT_USER=ubuntu
    CLIENT_ADDR=ec2-52-63-140-157.ap-southeast-2.compute.amazonaws.com
    WATCHDOG_USER=ubuntu
    WATCHDOG_ADDR=ec2-52-62-39-219.ap-southeast-2.compute.amazonaws.com
    SERVICE_USER=ubuntu
    SERVICE_AMI=ami-fae5c999
    $

The command-line arguments are:

keyfile: the full path to a .pem key file that will be used to access instances
over ssh. The file name will consist of the key name with the .pem extension, so
you can extract the key name from the file name.
aws_access_key_id: the AWS access key ID that is used as AWS credentials.
aws_secret_access_key: the AWS secret access key that is used as AWS
credentials.

The setup program must:

- Create an SQS queue.
- Create two S3 buckets: one for input, one for output.
- Launch and configure an EC2 client instance from which minimoto_client can be
run. This instance must contain the minimoto_client program and anything else
required to run it (except the images used as input data).
- Launch and configure an EC2 watchdog instance from which minimoto_watchdog can
be run. This instance must contain the minimoto_watchdog program and anything
else required to run it. Note that this instance should not automatically run
the watchdog.
- Launch and configure an EC2 service instance which will regularly run the
transcoding service. This instance must contain everything required to run the
transcoding service, and be configured to run the transcoding service regularly.
- Create an AMI based on the EC2 service instance that the watchdog can use to
launch new EC2 service instances.
- Create and configure any other resources needed to run the client, watchdog,
and transcoding service.

Some further notes:

- All the EC2 instances must allow ssh access to them using the given keyfile.
- Use the ap-southeast-2 AWS region, i.e., create all resources and run all
instances in this region. Do not use other regions.
- Since the setup program must perform a lot of work, the program may take a
long time to run. However, if it takes more than 10 minutes, please note this
and explain the reasons in your DESIGN doc.

minimoto_setup will have to pass information on to minimoto_cleanup about what
resources were created. One way to do this is using a shared file (that
minimoto_setup writes to and minimoto_cleanup reads from).

The mandatory output messages are as follows:

S3_BUCKET_INPUT=... : the S3 URL of the input bucket
S3_BUCKET_OUTPUT=... : the S3 URL of the output bucket
CLIENT_USER=... : the user name used to log in to the client EC2 instance
CLIENT_ADDR=... : the address of the client EC2 instance
WATCHDOG_USER=... : the user name used to log in to the watchdog EC2 instance
WATCHDOG_ADDR=... : the address of the watchdog EC2 instance
SERVICE_USER=...: the user name used to log in to a service EC2 instance
SERVICE_AMI=...: the ID of the AMI used for service instances

The setup program may print out other messages regarding its progress, it is up
to you what those messages are.
"""

# TODO check failure
# TODO figure out what minimoto_cleanup neeeds to know and print to a file for minimoto_cleanup

import os
import sys
import boto3
import subprocess

from minimoto_constants import *


def start_instance(ec2, filename, keyname, userdata):
    with open(userdata, "r") as userdatafile:
        instances = ec2.create_instances(
            ImageId="ami-96666ff5",
            MinCount=1,
            MaxCount=1,
            InstanceType="t2.small",
            KeyName=keyname,
            SecurityGroups=[SECURITY_GROUP_NAME],
            UserData=userdatafile.read()
        )
    return instances[0]


def setup_instance(instance, files, keyfile):
    instance.reload()
    instance_url = instance.public_dns_name

    # Upload necessary files
    for filename in files:
        print("Uploading " + filename)

        subprocess.check_call(["scp", "-o", "StrictHostKeyChecking no", "-i",
                               keyfile, filename,
                               "%s@%s:/home/%s/" % (USER, instance_url, USER)])


'''
Things to store:
    sqs QueueUrl
    instance id for client, watchdog, first instance
    imageId
'''
def main():
    if len(sys.argv) < 4:
        print("Not enough arguments")
        exit(1)
    keyfile = sys.argv[1]
    aws_access_key_id = sys.argv[2]
    aws_secret_access_key = sys.argv[3]

    print("Setting keys and region")
    subprocess.run(["aws", "configure", "set", "aws_access_key_id",
                    aws_access_key_id])
    subprocess.run(["aws", "configure", "set", "aws_secret_access_key",
                    aws_secret_access_key])
    subprocess.run(["aws", "configure", "set", "region", "ap-southeast-2"])

    print("Get boto3 clients")
    sqs = boto3.resource("sqs")
    s3 = boto3.resource("s3")
    ec2 = boto3.resource("ec2")

    print("Creating SQS queue")
    sqs.create_queue(QueueName=TRANSCODING_REQUESTS_QUEUE_NAME,
                     Attributes={"VisibilityTimeout": "30"})

    print("Creating input S3 bucket")
    try:
        s3.create_bucket(Bucket=INPUT_BUCKET_NAME,
                         CreateBucketConfiguration={
                            "LocationConstraint": "ap-southeast-2"
                         })
    except boto3.exceptions.botocore.errorfactory.ClientError as e:
        if e.response["Error"]["Code"] == "BucketAlreadyOwnedByYou":
            print("Bucket already exists")
        else:
            raise
    input_bucket_url = "s3://" + INPUT_BUCKET_NAME

    print("Creating output S3 bucket")
    try:
        s3.create_bucket(Bucket=OUTPUT_BUCKET_NAME,
                         CreateBucketConfiguration={
                            "LocationConstraint": "ap-southeast-2"
                         })
    except boto3.exceptions.botocore.errorfactory.ClientError as e:
        if e.response["Error"]["Code"] == "BucketAlreadyOwnedByYou":
            print("Bucket already exists")
        else:
            raise
    output_bucket_url = "s3://" + OUTPUT_BUCKET_NAME

    print("Importing the key pair")
    keyname = os.path.basename(keyfile)[:-4]
    material = subprocess.check_output(["ssh-keygen", "-y", "-f", keyfile])
    try:
        ec2.import_key_pair(
            KeyName=keyname,
            PublicKeyMaterial=material
        )
    except boto3.exceptions.botocore.errorfactory.ClientError as e:
        if e.response["Error"]["Code"] == "InvalidKeyPair.Duplicate":
            print("Key pair already exists")
        else:
            raise

    print("Creating a security group that allows ssh access")
    try:
        security_group = ec2.create_security_group(
            GroupName=SECURITY_GROUP_NAME,
            Description="ssh access"
        )

        security_group.authorize_ingress(
            IpProtocol="TCP",
            FromPort=22,
            ToPort=22,
            CidrIp='0.0.0.0/0'
        )
    except boto3.exceptions.botocore.errorfactory.ClientError as e:
        if e.response["Error"]["Code"] == "InvalidGroup.Duplicate":
            print("Security group already exists")
        else:
            raise

    print("Starting EC2 client instance")
    client_instance = start_instance(ec2, "minimoto_client", keyname,
                                     "minimoto_default_userdata")

    print("Starting EC2 watchdog instance")
    watchdog_instance = start_instance(ec2, "minimoto_watchdog", keyname,
                                       "minimoto_default_userdata")

    print("Starting EC2 service instance")
    service_instance = start_instance(ec2, "minimoto_service", keyname,
                                      "minimoto_service_userdata")

    print("Waiting until instances OK")
    # This should wait until the init script for all instances has finished
    waiter = boto3.client('ec2').get_waiter("instance_status_ok")
    waiter.wait(InstanceIds=[
        client_instance.id,
        watchdog_instance.id,
        service_instance.id,
    ])

    print("Setting up EC2 client instance")
    setup_instance(client_instance,
                   ["minimoto_client", "minimoto_constants.py"],
                   keyfile)
    client_url = client_instance.public_dns_name

    print("Setting up EC2 watchdog instance")
    setup_instance(watchdog_instance,
                   ["minimoto_watchdog", "minimoto_constants.py"],
                   keyfile)
    watchdog_url = watchdog_instance.public_dns_name

    print("Setting up EC2 service instance")
    setup_instance(service_instance,
                   ["minimoto_service", "img2video", "minimoto_constants.py"],
                   keyfile)

    print("Creating AMI from EC2 service instance for watchdog")
    service_ami = service_instance.create_image(Name=SERVICE_AMI_NAME)
    service_ami.wait_until_exists(Filters=[
        {
            "Name": "state",
            "Values": [
                "available",
            ]
        },
    ])
    waiter.wait(InstanceIds=[service_instance.id])

    print("minimoto_setup: mandatory output messages follow:")
    print("S3_BUCKET_INPUT={}".format(input_bucket_url))    # the S3 URL of the input bucket
    print("S3_BUCKET_OUTPUT={}".format(output_bucket_url))  # the S3 URL of the output bucket
    print("CLIENT_USER={}".format(USER))                    # the user name used to log in to the client EC2 instance
    print("CLIENT_ADDR={}".format(client_url))              # the address of the client EC2 instance
    print("WATCHDOG_USER={}".format(USER))                  # the user name used to log in to the watchdog EC2 instance
    print("WATCHDOG_ADDR={}".format(watchdog_url))          # the address of the watchdog EC2 instance
    print("SERVICE_USER={}".format(USER))                   # the user name used to log in to a service EC2 instance
    print("SERVICE_AMI={}".format(service_ami.id))          # the ID of the AMI used for service instances


if __name__ == "__main__":
    main()

